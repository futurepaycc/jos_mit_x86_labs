<!DOCTYPE html>
<!-- saved from url=(0064)file:///var/folders/4x/p752xljj6yvdxpx5v_qrtld40000gn/T/159.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>README</title></head><body><h1 id="report-for-lab4-shian-chen">Report for lab4, Shian Chen</h1>
<blockquote>
<p>all exercises finished </p>
<p>one challenge completed</p>
</blockquote>
<pre><code>make[1]: Leaving directory `/home/clann/lab4'
dumbfork: OK (5.0s) 
Part A score: 5/5

faultread: OK (4.6s) 
faultwrite: OK (4.7s) 
faultdie: OK (4.6s) 
faultregs: OK (4.6s) 
faultalloc: OK (4.6s) 
faultallocbad: OK (4.6s) 
faultnostack: OK (4.6s) 
faultbadhandler: OK (4.6s) 
faultevilhandler: OK (4.6s) 
forktree: OK (4.8s) 
Part B score: 50/50

spin: OK (4.7s) 
stresssched: OK (6.9s) 
pingpong: OK (4.8s) 
primes: OK (47.2s) 
Part C score: 20/20

Score: 75/75
</code></pre>

<h2 id="part-a-multiprocessor-support-and-cooperative-multitasking">Part A: Multiprocessor Support and Cooperative Multitasking</h2>
<p>Exercise 1</p>
<pre><code>Exercise 1. Implement mmio_map_region in kern/pmap.c. To see how this is used, look at the beginning of lapic_init in kern/lapic.c. You'll have to do the next exercise, too, before the tests for mmio_map_region will run.
</code></pre>

<p>Note the way <code>size</code> is aligned, can't use <code>size=ROUNDUP(size)</code> directly:</p>
<pre><code class="c">void *
mmio_map_region(physaddr_t pa, size_t size)
{
    static uintptr_t base = MMIOBASE;
    size = ROUNDUP(pa+size, PGSIZE);
    pa = ROUNDDOWN(pa, PGSIZE);
    size -= pa;
    if (base+size &gt;= MMIOLIM) panic("not enough memory");
    boot_map_region(kern_pgdir, base, size, pa, PTE_PCD|PTE_PWT|PTE_W);
    base += size;
    return (void*) (base - size);
}
</code></pre>

<h2 id="exercise-2">Exercise 2</h2>
<pre><code>Exercise 2. Read boot_aps() and mp_main() in kern/init.c, and the assembly code in kern/mpentry.S. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of page_init() in kern/pmap.c to avoid adding the page at MPENTRY_PADDR to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated check_page_free_list() test (but might fail the updated check_kern_pgdir() test, which we will fix soon).
</code></pre>

<p>Just modify the upper bound of free base memory to MPENTRY_PADDR:</p>
<pre><code class="c">void
page_init(void)
{
    ...
    size_t i;
    for (i = 1; i &lt; MPENTRY_PADDR/PGSIZE; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &amp;pages[i];
    }
    ...
}
</code></pre>

<h2 id="question">Question</h2>
<blockquote>
<p>Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S? </p>
</blockquote>
<p>Beacuse <code>mentry.S</code> is loaded by bootloader without any special treatment whereas it has to be loaded by bootstrap CPU to <code>0x7000</code>, so we have to deliminate the original load address and plus an offset we want.</p>
<h2 id="exercise-3">Exercise 3</h2>
<pre><code>Exercise 3. Modify mem_init_mp() (in kern/pmap.c) to map per-CPU stacks starting at KSTACKTOP, as shown in inc/memlayout.h. The size of each stack is KSTKSIZE bytes plus KSTKGAP bytes of unmapped guard pages. Your code should pass the new check in check_kern_pgdir().
</code></pre>

<p>Easy, but we will now have KSTKSIZE of memory in <code>bootstack</code> wasted:</p>
<pre><code class="c">static void
mem_init_mp(void)
{
    int i;
    for (i = 0; i &lt; NCPU; ++i) {
        boot_map_region(kern_pgdir, 
            KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP), 
            KSTKSIZE, 
            PADDR(percpu_kstacks[i]), 
            PTE_W);
    }
}
</code></pre>

<h2 id="exercise-4">Exercise 4</h2>
<pre><code>Exercise 4. The code in trap_init_percpu() (kern/trap.c) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global ts variable any more.)
</code></pre>

<p>Be aware that <code>ltr(GD_TSS0)</code> should be changed to <code>ltr(GD_TSS0+8*cid)</code>:</p>
<pre><code class="c">void
trap_init_percpu(void)
{
    int cid = thiscpu-&gt;cpu_id;
    thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cid * (KSTKSIZE + KSTKGAP);
    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;
    gdt[(GD_TSS0 &gt;&gt; 3)+cid] = SEG16(STS_T32A, (uint32_t) (&amp;(thiscpu-&gt;cpu_ts)),
                    sizeof(struct Taskstate), 0);
    gdt[(GD_TSS0 &gt;&gt; 3)+cid].sd_s = 0;
    ltr(GD_TSS0+8*cid);
    lidt(&amp;idt_pd);
}
</code></pre>

<h2 id="exercise-5">Exercise 5</h2>
<pre><code>Exercise 5. Apply the big kernel lock as described above, by calling lock_kernel() and unlock_kernel() at the proper locations.
</code></pre>

<p>Easy.</p>
<h2 id="question_1">Question</h2>
<blockquote>
<p>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</p>
</blockquote>
<p>Although <code>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time</code>, it is not necessarily true. When an interupt occurs, the hardware automaticly pushes </p>
<ul>
<li>uint32_t tf_err;</li>
<li>uintptr_t tf_eip;</li>
<li>uint16_t tf_cs;</li>
<li>uint16_t tf_padding3;</li>
<li>uint32_t tf_eflags;</li>
</ul>
<p>to the stack <em>before</em> checking the lock, so it will just mess up.</p>
<h2 id="exercise-6">Exercise 6</h2>
<pre><code>Exercise 6. Implement round-robin scheduling in sched_yield() as described above. Don't forget to modify syscall() to dispatch sys_yield().

Modify kern/init.c to create three (or more!) environments that all run the program user/yield.c. You should see the environments switch back and forth between each other five times before terminating, like this:

...
Hello, I am environment 00001000.
Hello, I am environment 00001001.
Hello, I am environment 00001002.
Back in environment 00001000, iteration 0.
Back in environment 00001001, iteration 0.
Back in environment 00001002, iteration 0.
Back in environment 00001000, iteration 1.
Back in environment 00001001, iteration 1.
Back in environment 00001002, iteration 1.
...
After the yield programs exit, there will be no runnable environment in the system, the scheduler should invoke the JOS kernel monitor. If any of this does not happen, then fix your code before proceeding.
</code></pre>

<p>Be aware of the <code>curenv</code> may be null:</p>
<pre><code class="c">void
sched_yield(void)
{
    struct Env *idle;
    struct Env *e;
    int i, cur=0;
    if (curenv) cur=ENVX(curenv-&gt;env_id);
        else cur = 0;
    for (i = 0; i &lt; NENV; ++i) {
        int j = (cur+i) % NENV;
        if (j &lt; 2) cprintf("envs[%x].env_status: %x\n", j, envs[j].env_status);
        if (envs[j].env_status == ENV_RUNNABLE) {
            if (j == 1) 
                cprintf("\n");
            env_run(envs + j);
        }
    }
    if (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)
        env_run(curenv);
    sched_halt();
}
</code></pre>

<h2 id="question_2">Question</h2>
<blockquote>
<p>In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context--the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch?</p>
</blockquote>
<p>Because the kernel part of vm of all environments are identical.</p>
<blockquote>
<p>Whenever the kernel switches from one environment to another, it must ensure the old environment's registers are saved so they can be restored properly later. Why? Where does this happen?</p>
</blockquote>
<p>Obviouly <code>curenv-&gt;env_tf = *tf;</code> in <code>trap.c</code> saves the current trap frame.</p>
<h2 id="exercise-7">Exercise 7</h2>
<pre><code>Exercise 7. Implement the system calls described above in kern/syscall.c. You will need to use various functions in kern/pmap.c and kern/env.c, particularly envid2env(). For now, whenever you call envid2env(), pass 1 in the checkperm parameter. Be sure you check for any invalid system call arguments, returning -E_INVAL in that case. Test your JOS kernel with user/dumbfork and make sure it works before proceeding.
</code></pre>

<p>Please see <code>kern/syscall.c</code> for details because there's too much code. One tip for this exercise: Be aware of the difference between <code>page_insert</code> and <code>page_alloc</code>.</p>
<h2 id="challenge">Challenge</h2>
<pre><code>Challenge! Add a less trivial scheduling policy to the kernel, such as a fixed-priority scheduler that allows each environment to be assigned a priority and ensures that higher-priority environments are always chosen in preference to lower-priority environments. If you're feeling really adventurous, try implementing a Unix-style adjustable-priority scheduler or even a lottery or stride scheduler. (Look up "lottery scheduling" and "stride scheduling" in Google.)

Write a test program or two that verifies that your scheduling algorithm is working correctly (i.e., the right environments get run in the right order). It may be easier to write these test programs once you have implemented fork() and IPC in parts B and C of this lab.
</code></pre>

<p>This challenge was completed after I finished all exercises.</p>
<p>I implemented a fixed-priority scheduling. First add a <code>pr</code> field in <code>struct Env</code> to indicate the priority, the lower <code>pr</code> the higher the priority. Then modify the <code>sched_yield</code> to consider the <code>pr</code> field, be aware of the condition to run <code>curenv</code>, don't be confused with the <code>&amp;&amp;</code> and <code>||</code> and the order of every argument, or it will cause problem in multiprocessor condition (well, obviously I had gotten in trouble with that when I was debugging or I'd not bother say it):</p>
<pre><code class="c">void
sched_yield(void)
{
    struct Env *idle;
    struct Env *e, *runenv = NULL;
    int i, cur=0;
    if (curenv) cur=ENVX(curenv-&gt;env_id);
    else cur = 0;
    for (i = 0; i &lt; NENV; ++i) {
        int j = (cur+i) % NENV;
        if (envs[j].env_status == ENV_RUNNABLE) {
            if (runenv==NULL || envs[j].pr &lt; runenv-&gt;pr) 
                runenv = envs+j; 
        }
    }
    if (curenv &amp;&amp; (curenv-&gt;env_status == ENV_RUNNING) &amp;&amp; ((runenv==NULL) || (curenv-&gt;pr &lt; runenv-&gt;pr))) {
        env_run(curenv);
    }
    if (runenv) {
        env_run(runenv);
    }
    sched_halt();
}
</code></pre>

<p>The priority of a process should be set in the creation by his father process and can be changed by himself, 
so I added a system call <code>sys_change_pr(int pr)</code> to enable modifying of priority, this involve lots of modification in many files and at last one implementation in <code>kern/syscall.c</code>:</p>
<pre><code class="c">int sys_change_pr(int pr) {
    curenv-&gt;pr = pr;
    return 0;
}
</code></pre>

<p>I added a new function <code>pfork</code> rather than modify the odd one for compatibility with <code>grade scripts</code>, every child has a <code>pr</code> 0 when it is created to ensure it can run at least one time except there's a very high priority process that has a negative <code>pr</code>, then the child process call the system call to change his own <code>pr</code> properly:</p>
<pre><code class="c">envid_t
pfork(int pr)
{
    set_pgfault_handler(pgfault);

    envid_t envid;
    uint32_t addr;
    envid = sys_exofork();
    if (envid == 0) {
        thisenv = &amp;envs[ENVX(sys_getenvid())];
        sys_change_pr(pr);
        return 0;
    }

    if (envid &lt; 0)
        panic("sys_exofork: %e", envid);

    for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE)
        if ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P)
            &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) {
            duppage(envid, PGNUM(addr));
        }

    if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P) &lt; 0)
        panic("1");
    extern void _pgfault_upcall();
    sys_env_set_pgfault_upcall(envid, _pgfault_upcall);

    if (sys_env_set_status(envid, ENV_RUNNABLE) &lt; 0)
        panic("sys_env_set_status");

    return envid;
    panic("fork not implemented");
}
</code></pre>

<p>I changed the <code>hello.c</code> to test my implementation:</p>
<pre><code class="c">#include &lt;inc/lib.h&gt;

void
umain(int argc, char **argv)
{
    int i;
    for (i = 1; i &lt;= 5; ++i) {
        int pid = pfork(i);
        if (pid == 0) {
            cprintf("child %x is now living!\n", i);
            int j;
            for (j = 0; j &lt; 5; ++j) {
                cprintf("child %x is yielding!\n", i);
                sys_yield();
            }
            break;
        }
    }
}
</code></pre>

<p>Every time the scheduler runs, the one with lowest priority should be run, and the output meets this rule well and the <code>grade scripts</code> still reports <code>OK</code> on all tests:</p>
<pre><code>[00000000] new env 00001000
envs[0].pr: 0
[00001000] new env 00001001
envs[0].pr: 0
[00001000] new env 00001002
envs[1].pr: 0
child 1 is now living!
child 1 is yielding!
envs[0].pr: 0
[00001000] new env 00001003
envs[1].pr: 1
envs[2].pr: 0
child 2 is now living!
child 2 is yielding!
envs[0].pr: 0
envs[1].pr: 1
envs[1].pr: 1
envs[2].pr: 2
envs[0].pr: 0
[00001000] new env 00001004
envs[1].pr: 1
envs[2].pr: 2
envs[3].pr: 0
child 3 is now living!
child 3 is yielding!
envs[0].pr: 0
envs[1].pr: 1
envs[2].pr: 2
[00001000] new env 00001005
envs[1].pr: 1
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 0
child 4 is now living!
child 4 is yielding!
envs[0].pr: 0
envs[1].pr: 1
envs[2].pr: 2
envs[3].pr: 3
[00001000] exiting gracefully
[00001000] free env 00001000
envs[1].pr: 1
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 0
child 5 is now living!
child 5 is yielding!
envs[1].pr: 1
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
child 1 is yielding!
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[1].pr: 1
child 1 is yielding!
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[1].pr: 1
child 1 is yielding!
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[1].pr: 1
child 1 is yielding!
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[1].pr: 1
[00001001] exiting gracefully
[00001001] free env 00001001
envs[2].pr: 2
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
child 2 is yielding!
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[2].pr: 2
child 2 is yielding!
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[2].pr: 2
child 2 is yielding!
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[2].pr: 2
child 2 is yielding!
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
envs[2].pr: 2
[00001002] exiting gracefully
[00001002] free env 00001002
envs[3].pr: 3
envs[4].pr: 4
envs[5].pr: 5
child 3 is yielding!
envs[4].pr: 4
envs[5].pr: 5
envs[3].pr: 3
child 3 is yielding!
envs[4].pr: 4
envs[5].pr: 5
envs[3].pr: 3
child 3 is yielding!
envs[4].pr: 4
envs[5].pr: 5
envs[3].pr: 3
child 3 is yielding!
envs[4].pr: 4
envs[5].pr: 5
envs[3].pr: 3
[00001003] exiting gracefully
[00001003] free env 00001003
envs[4].pr: 4
envs[5].pr: 5
child 4 is yielding!
envs[5].pr: 5
envs[4].pr: 4
child 4 is yielding!
envs[5].pr: 5
envs[4].pr: 4
child 4 is yielding!
envs[5].pr: 5
envs[4].pr: 4
child 4 is yielding!
envs[5].pr: 5
envs[4].pr: 4
[00001004] exiting gracefully
[00001004] free env 00001004
envs[5].pr: 5
child 5 is yielding!
envs[5].pr: 5
child 5 is yielding!
envs[5].pr: 5
child 5 is yielding!
envs[5].pr: 5
child 5 is yielding!
envs[5].pr: 5
[00001005] exiting gracefully
[00001005] free env 00001005
envs[0].env_status: 0
envs[1].env_status: 0
No runnable environments in the system!
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
blue
green
red
</code></pre>

<h2 id="part-b-copy-on-write-fork">Part B: Copy-on-Write Fork</h2>
<h2 id="exercise-8">Exercise 8</h2>
<pre><code>Exercise 8. Implement the sys_env_set_pgfault_upcall system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a "dangerous" system call.
</code></pre>

<p>Can't be easier, no comments for the code:</p>
<pre><code class="c">static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
    struct Env *e; 
    int ret = envid2env(envid, &amp;e, 1);
    if (ret) return ret;    //bad_env
    e-&gt;env_pgfault_upcall = func;
    return 0;
}
</code></pre>

<h2 id="exercise-9">Exercise 9</h2>
<pre><code>Exercise 9. Implement the code in page_fault_handler in kern/trap.c required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)
</code></pre>

<p>We have to check <code>utf_addr</code> for validation:</p>
<pre><code class="c">void
page_fault_handler(struct Trapframe *tf)
{
    uint32_t fault_va;
    fault_va = rcr2();
    cprintf("fault_va: %x\n", fault_va);
    // LAB 3: Your code here.
    if ((tf-&gt;tf_cs&amp;3) == 0) {
        panic("Kernel page fault!");
    }
    // LAB 4: Your code here.
    if (curenv-&gt;env_pgfault_upcall) {
        struct UTrapframe *utf;
        uintptr_t utf_addr;
        if (UXSTACKTOP-PGSIZE&lt;=tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp&lt;=UXSTACKTOP-1)
            utf_addr = tf-&gt;tf_esp - sizeof(struct UTrapframe) - 4;
        else 
            utf_addr = UXSTACKTOP - sizeof(struct UTrapframe);
        user_mem_assert(curenv, (void*)utf_addr, 1, PTE_W);//1 is enough
        utf = (struct UTrapframe *) utf_addr;

        utf-&gt;utf_fault_va = fault_va;
        utf-&gt;utf_err = tf-&gt;tf_err;
        utf-&gt;utf_regs = tf-&gt;tf_regs;
        utf-&gt;utf_eip = tf-&gt;tf_eip;
        utf-&gt;utf_eflags = tf-&gt;tf_eflags;
        utf-&gt;utf_esp = tf-&gt;tf_esp;

        curenv-&gt;env_tf.tf_eip = (uintptr_t)curenv-&gt;env_pgfault_upcall;
        curenv-&gt;env_tf.tf_esp = utf_addr;
        env_run(curenv);
    }

    // Destroy the environment that caused the fault.
    cprintf("[%08x] user fault va %08x ip %08x\n",
        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);
    print_trapframe(tf);
    env_destroy(curenv);
}
</code></pre>

<h2 id="exercise-10">Exercise 10</h2>
<pre><code>Exercise 10. Implement the _pgfault_upcall routine in lib/pfentry.S. The interesting part is returning to the original point in the user code that caused the page fault. You'll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.
</code></pre>

<p>See the comments:</p>
<pre><code class="asm">.text
.globl _pgfault_upcall
_pgfault_upcall:
    // Call the C page fault handler.
    pushl %esp          // function argument: pointer to UTF
    movl _pgfault_handler, %eax
    call *%eax
    addl $4, %esp           // pop function argument

    movl 0x28(%esp), %edx # trap-time eip
    subl $0x4, 0x30(%esp) # we have to use subl now because we can't use after popfl
    movl 0x30(%esp), %eax # trap-time esp-4
    movl %edx, (%eax)
    addl $0x8, %esp

    // Restore the trap-time registers.  After you do this, you
    // can no longer modify any general-purpose registers.
    // LAB 4: Your code here.
    popal

    // Restore eflags from the stack.  After you do this, you can
    // no longer use arithmetic operations or anything else that
    // modifies eflags.
    // LAB 4: Your code here.
    addl $0x4, %esp #eip
    popfl

    // Switch back to the adjusted trap-time stack.
    // LAB 4: Your code here.
    popl %esp

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.
    ret
</code></pre>

<h2 id="exercise-11">Exercise 11</h2>
<pre><code>Exercise 11. Finish set_pgfault_handler() in lib/pgfault.c.
</code></pre>

<p>Just follow the guide:</p>
<pre><code class="c">void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
    int r;

    if (_pgfault_handler == 0) {
        if (sys_page_alloc(0, (void*)(UXSTACKTOP-PGSIZE), PTE_W|PTE_U|PTE_P) &lt; 0) 
            panic("set_pgfault_handler:sys_page_alloc failed");;
    }
    // Save handler pointer for assembly to call.
    _pgfault_handler = handler;
    if (sys_env_set_pgfault_upcall(0, _pgfault_upcall) &lt; 0)
        panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed");
}
</code></pre>

<h2 id="exercise-12">Exercise 12</h2>
<pre><code>Exercise 12. Implement fork, duppage and pgfault in lib/fork.c.

Test your code with the forktree program. It should produce the following messages, with interspersed 'new env', 'free env', and 'exiting gracefully' messages. The messages may not appear in this order, and the environment IDs may be different.

    1000: I am ''
    1001: I am '0'
    2000: I am '00'
    2001: I am '000'
    1002: I am '1'
    3000: I am '11'
    3001: I am '10'
    4000: I am '100'
    1003: I am '01'
    5000: I am '010'
    4001: I am '011'
    2002: I am '110'
    1004: I am '001'
    1005: I am '111'
    1006: I am '101'
</code></pre>

<p><code>PFTEMP</code> is used as a temporary vm for storing a physical page:</p>
<pre><code class="c">static void
pgfault(struct UTrapframe *utf)
{
    void *addr = (void *) utf-&gt;utf_fault_va;
    uint32_t err = utf-&gt;utf_err;
    int r;

    if (!(
            (err &amp; FEC_WR) &amp;&amp; (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; 
            (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW)))
        panic("not copy-on-write");

    addr = ROUNDDOWN(addr, PGSIZE);
    if (sys_page_alloc(0, PFTEMP, PTE_W|PTE_U|PTE_P) &lt; 0)
        panic("sys_page_alloc");
    memcpy(PFTEMP, addr, PGSIZE);
    if (sys_page_map(0, PFTEMP, 0, addr, PTE_W|PTE_U|PTE_P) &lt; 0)
        panic("sys_page_map");
    if (sys_page_unmap(0, PFTEMP) &lt; 0)
        panic("sys_page_unmap");
    return;
}
</code></pre>

<p>Permissions is checked beforehand so just test the <code>PTE_W</code> and <code>PTE_COW</code>:</p>
<pre><code class="c">static int
duppage(envid_t envid, unsigned pn)
{
    int r;
    // LAB 4: Your code here.
    void *addr = (void*) (pn*PGSIZE);
    if ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) {
        if (sys_page_map(0, addr, envid, addr, PTE_COW|PTE_U|PTE_P) &lt; 0)
            panic("2");
        if (sys_page_map(0, addr, 0, addr, PTE_COW|PTE_U|PTE_P) &lt; 0)
            panic("3");
    } else sys_page_map(0, addr, envid, addr, PTE_U|PTE_P);
    return 0;
    panic("duppage not implemented");
}
</code></pre>

<p>We have to check <code>uvpd</code> present first to avoid page fault in accessing uvpt:</p>
<pre><code class="c">envid_t
fork(void)
{
    set_pgfault_handler(pgfault);

    envid_t envid;
    uint32_t addr;
    envid = sys_exofork();
    if (envid == 0) {
        // panic("child");
        thisenv = &amp;envs[ENVX(sys_getenvid())];
        return 0;
    }
    // cprintf("sys_exofork: %x\n", envid);
    if (envid &lt; 0)
        panic("sys_exofork: %e", envid);

    for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE)
        if ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P)
            &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) {
            duppage(envid, PGNUM(addr));
        }

    if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P) &lt; 0)
        panic("1");
    extern void _pgfault_upcall();
    sys_env_set_pgfault_upcall(envid, _pgfault_upcall);

    if (sys_env_set_status(envid, ENV_RUNNABLE) &lt; 0)
        panic("sys_env_set_status");

    return envid;
    panic("fork not implemented");
}
</code></pre>

<h2 id="part-c-preemptive-multitasking-and-inter-process-communication-ipc">Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2>
<h2 id="exercise-13">Exercise 13</h2>
<pre><code>Exercise 13. Modify kern/trapentry.S and kern/trap.c to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in env_alloc() in kern/env.c to ensure that user environments are always run with interrupts enabled.
</code></pre>

<p>Generate 16 entries of funs using a script language (whatever you like, I use python):</p>
<pre><code>    noec(th32, 32)
    noec(th33, 33)
    noec(th34, 34)
    noec(th35, 35)
    noec(th36, 36)
    noec(th37, 37)
    noec(th38, 38)
    noec(th39, 39)
    noec(th40, 40)
    noec(th41, 41)
    noec(th42, 42)
    noec(th43, 43)
    noec(th44, 44)
    noec(th45, 45)
    noec(th46, 46)
    noec(th47, 47)
</code></pre>

<p>Add a <code>for</code> loop in <code>trap.c</code> to set up gates:</p>
<pre><code class="c">for (i = 0; i &lt; 16; ++i)
    SETGATE(idt[IRQ_OFFSET+i], 0, GD_KT, funs[IRQ_OFFSET+i], 0);
</code></pre>

<p>And enable <code>FL_IF</code> in user env:</p>
<pre><code class="c">    e-&gt;env_tf.tf_eflags |= FL_IF;
</code></pre>

<h2 id="exercise-14">Exercise 14</h2>
<pre><code>Exercise 14. Modify the kernel's trap_dispatch() function so that it calls sched_yield() to find and run a different environment whenever a clock interrupt takes place.
</code></pre>

<p>Trivial:</p>
<pre><code class="c">    if (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
        lapic_eoi();
        sched_yield();
        return;
    }
</code></pre>

<h2 id="exercise-15">Exercise 15</h2>
<pre><code>Exercise 15. Implement sys_ipc_recv and sys_ipc_try_send in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call envid2env in these routines, you should set the checkperm flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.

Then implement the ipc_recv and ipc_send functions in lib/ipc.c.
</code></pre>

<p>Most of code is checking, just follow the guide:</p>
<pre><code class="c">static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
    struct Env *e;
    int ret = envid2env(envid, &amp;e, 0);
    if (ret) return ret;//bad env
    if (!e-&gt;env_ipc_recving) return -E_IPC_NOT_RECV;
    if (srcva &lt; (void*)UTOP) {
        pte_t *pte;
        struct PageInfo *pg = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte);
        if (!pg) return -E_INVAL;
        if ((*pte &amp; perm) != perm) return -E_INVAL;
        if ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) return -E_INVAL;
        if (srcva != ROUNDDOWN(srcva, PGSIZE)) return -E_INVAL;
        if (e-&gt;env_ipc_dstva &lt; (void*)UTOP) {
            ret = page_insert(e-&gt;env_pgdir, pg, e-&gt;env_ipc_dstva, perm);
            if (ret) return ret;
            e-&gt;env_ipc_perm = perm;
        }
    }
    e-&gt;env_ipc_recving = 0;
    e-&gt;env_ipc_from = curenv-&gt;env_id;
    e-&gt;env_ipc_value = value; 
    e-&gt;env_status = ENV_RUNNABLE;
    e-&gt;env_tf.tf_regs.reg_eax = 0;
    return 0;
    panic("sys_ipc_try_send not implemented");
}
</code></pre>

<p>Trivial:</p>
<pre><code class="c">static int
sys_ipc_recv(void *dstva)
{
    if (dstva &lt; (void*)UTOP) 
        if (dstva != ROUNDDOWN(dstva, PGSIZE)) 
            return -E_INVAL;
    curenv-&gt;env_ipc_recving = 1;
    curenv-&gt;env_status = ENV_NOT_RUNNABLE;
    curenv-&gt;env_ipc_dstva = dstva;
    sys_yield();
    return 0;
}
</code></pre>

<p>(void*)-1 is used to indicate no page:</p>
<pre><code class="c">int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
    // LAB 4: Your code here.
    if (from_env_store) *from_env_store = 0;
    if (perm_store) *perm_store = 0;
    if (!pg) pg = (void*) -1;
    int ret = sys_ipc_recv(pg);
    if (ret) return ret;
    if (from_env_store)
        *from_env_store = thisenv-&gt;env_ipc_from;
    if (perm_store)
        *perm_store = thisenv-&gt;env_ipc_perm;
    return thisenv-&gt;env_ipc_value;
}
</code></pre>

<p>Use <code>sys_yield</code> to make code CPU friendly:</p>
<pre><code class="c">void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
    // LAB 4: Your code here.
    if (!pg) pg = (void*)-1;
    int ret;
    while ((ret = sys_ipc_try_send(to_env, val, pg, perm))) {
        if (ret == 0) break;
        if (ret != -E_IPC_NOT_RECV) panic("not E_IPC_NOT_RECV, %e", ret);
        sys_yield();
    }
}
</code></pre>

<p>There's something I have to mention here: after I finished the last exercise, I typed <code>make grade</code> and passed all tests but got a timeout in the <code>primes</code>, I found that this test was executed in a 4-CPU environment, I tried it in a 1-CPU environment and it finished quickly but it was much slower in a 4-CPU environment, I thought maybe it was due to the immatureness of <code>qemu</code> (and I were using the official <code>qemu</code> rather than the patched one), so I changed the grade time limit from <code>30s</code> to <code>60s</code> and finally passed all tests.</p>
<h1 id="this-completes-the-lab">This completes the lab.</h1></body></html>